1、正则表达式（这里为PREC STYLE, php 5.3.0以上废除了POSIX扩展，其实也差不多，但是POSIX没有二进制安全）

2、分隔符，同其他语言的正则，表达式的头尾需要加分隔符，也就是非数字、字母、反斜线和空白符的一对字符，一般用“/”、“#”等等，如果表达式里出现了分隔符，则需要加“\”转义之，因此分隔符应该使用表达式不出现或者出现次数较少的字符

3、元字符，也就是需要转义才能表示为纯字符的字符
    方括号外：
        \ ： 转义字符
        ^ ： 在字符串开始匹配
        $ ： 在字符串末尾匹配
        . ： 匹配除换行符之外的任意字符
        | ： 选择分支（也就是“或”啦）
        ( ： 子组模式的开始符
        ) ： 子组模式的结束符
        [ ： 字符类的开始符
        ] ： 字符类的结束符
    方括号内：
        \ ： 转义字符
        ^ ： 取反字符（反义字符）
        - ： 范围联符（比如，[a-zA-Z]）
    限定符：
        ? ： 匹配0次到1次，等价于{0,1}
        * ： 匹配0次或无数次，等价于{0,}
        + ： 匹配至少1次或无数次，等价于{1,}
        { ： 自定义量词的开始符
        } ： 自定义量词的结束符         

4、模式修饰符（表达式修饰符），加在分隔符之后，比如“#\d{1,6}\.\d{0,2}#i”，这里的“i”就是模式修饰符，指定这条表达式忽略大小写
    具体的模式修饰符有:
        i(PRCR_CASSLESS)                   : 忽略大小写
        m(PCRE_MULTILINE)                  : 搜索的内容为多行也就是有“\n”、行首"^"或者行未“$”出现时生效，不再只搜索一行会跨行搜索
        s(PCRE_DOTALL)                     : 使"."匹配换行符，不用这个的话，使用取反字符类[^a]也可以匹配换行符
        x(PRRE_EXTENDED)                   : 一个字符类外部的未转义的 # 字符就代表本行剩余部分为注释
        A(PCRE_ANCHORED)                   : 约束匹配使其仅从目标字符串的开始位置搜索
        D(PCRE_DOLLAR_ENDONLY)             : 使"$"不再匹配到行未，而是匹配到换行符之前，默认是跟着换行符一起匹配
        U(PCRE_UNGREEDY)                   : 这个模式下表达式里的贪婪算法（可以理解为匹配无数次的算法，比如".*"，“.”这个元字符匹配任意字符，“*”这个限定符重复0到无数次）全部变成非贪婪算法，其实没必要这么做，一般加个"?"（匹配0到1次）就可以了
        X(PCRE_EXTRA)                      : 这个模式下，如果表达式中的"\"转义符没有跟一个元字符，就会报错
        J(PCRE_INFO_JCHANGED)              : 允许子组重名
        u(PCRE_UTF8)                       : 用过python2都知道编码毁一生，而这个模式下使表达式被解释为utf-8
    内部模式修饰符：语法为“(?修饰符)”，支持的修饰符为i、m、s、x、U、X、J，如果一个内部修饰符没在子组内（也就是套括号内），将影响内部修饰符后的所有部分

5、转义序列
    常用：
        \d    ： 任意十进制数字
        \D    ： 任意非十进制数字
        \h    ： 任意水平空白字符
        \H    ： 任意非水平空白字符
        \s    ： 任意空白字符
        \S    ： 任意非空白字符
        \v    ： 任意垂直空白字符
        \V    ： 任意非垂直空白字符
        \w    ： 任意单词字符，等价于[a-zA-Z0-9_]（单词指合法的变量名，也就是字母、数字和下划线）
        \W    ： 任意非单词字符，等价于[^a-zA-Z0-9_]（单词指合法的变量名，也就是字母、数字和下划线）
        \b    ： 单词边界
        \B    ： 非单词边界
        \A    ： 目标的开始位置(独立于多行模式，也就是不受模式修饰符控制)
        \z    ： 目标的结束位置(独立于多行模式，也就是不受模式修饰符控制)
        \Z    ： 目标的结束位置或结束处的换行符(独立于多行模式，也就是不受模式修饰符控制)
        \G    ： 在目标中首次匹配位置
    其它：
        \a    ： 响铃字符
        \cx   ： "control-x"，x 是任意字符
        \e    ： 转义 (十六进制 1B)
        \f    ： 换页 (十六进制 0C)
        \n    ： 换行 (十六进制 0A)
        \p{xx}： 一个符合 xx 属性的字符
        \P{xx}： 一个不符合xx属性的字符
        \r    ： 回车 (十六进制 0D)
        \t    ： 水平制表符 (十六进制 09)
        \xhh  ： hh十六进制编码的字符
        \ddd  ： ddd八进制编码的字符
        \040  ： 空格的另外一种用法
        \40   ： 当提供了少于40个子组时也认为是空格
        \7    ： 始终是后向引用
        \11   ： 可能是后向引用，也可能是制表符
        \011  ： 总是一个制表符
        \0113 ： 一个制表符紧跟着一个3(因为每次最多只读取3个8进制位
        \113  ： 八进制113代表的字符
        \377  ： 8进制377是10进制255， 因此代表一个全1的字符
        \81   ： 一个后向引用或者一个二进制 0 紧跟着两个数字 8 和 1(因为8不是8进制有效数字)
        
6、字符类，使用"[:"和":]"闭合，支持的字符类：
    alnum  ： 字母和数字
    alpha  ： 字母
    ascii  ： 0-127的ascii字符
    blank  ： 空格和制表符
    cntrl  ： 控制字符
    digit  ： 十进制数，等同于"\d"
    graph  ： 打印字符，不包括空格
    lower  ： 小写字母，等同于"[a-z]"
    print  ： 打印字符，包含空格
    punct  ： 打印字符，不包含字母和数字
    space  ： 空白符
    upper  ： 大写字母，等同于"[A-Z]"
    word   ： 胆子字符，等同与"\w"
    xdigit ： 十六进制数
    
7、子组，用"(expression)"括号套起来的表达式就是一个子组，一个表达式最大可以有200个子组，包括捕获和非捕获子组，非捕获子组的写法是"(?:expression)"，从左至右子组的下标从1开始计算，0代表整条表达式

8、后向引用，也就是通过"\x"（x表示捕获子组的索引）来作为表达式的一部分，比如用"(\w{4,4})\s\1"匹配"test1 Test test test"，将匹配出"test test"，用对应索引子组匹配的结果作为表达式

9、断言，其实就是指定哪些位置来匹配，比如行首"^"和行未"$"都是断言符，这部分看About_Regex目录下的正则笔记，概念是一样的

10、条件子组，语法为"(?(condition)yes-pattern)"或者"(?(condition)yes-pattern|no-pattern)"，类似三目运算符，当子组condition条件捕获成功时，匹配yes-pattern表达式，反之匹配no-pattern表达式

11、注释注释语法同其他语言的正则注释一样，(?#content)，content为注释内容，为了防止后面内容全被注释掉，可以用子组写法（也就是套括号），比如"(?#content)"