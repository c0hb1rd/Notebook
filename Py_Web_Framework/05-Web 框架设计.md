## Web 框架设计

## 一、实验说明
### 1.1 实验内容
本节主要讲解整个框架的设计，整理该有的模块，建立框架目录结构

### 1.2 涉及知识点
* 异常处理
* `WSGI`
* `URL` 路由
* 视图
* 模版引擎
* `HTTP 消息报头`
* 会话
* 数据库连接

### 1.3 实验环境
* `Python3`
* `sublimt` 编辑器
* `Xfce` 终端

## 二、分析需求
### 2.1 如何确定模块
对于如何确定哪些是必备模块，可以这么来判断。在每一次 `Web 应用程序` 开发中，从开始运行，获取请求，到返回结果给服务器之间，几乎都会使用到的功能，就可以确定是必备模块了。

### 2.2 模块分析
#### 2.2.1 异常处理
这是每一个软件工程中几乎会涵盖到的模块，所以毫无疑问可以直接列在第一位。

#### 2.2.2 WSGI 入口模块
对于 `Python` 脚本写的 `Web` 应用程序，服务器是没法直接解释运行的，全部都要经由 `WSGI` 调度才能通过 `Python` 脚本解释处理服务器的请求和返回响应，所以 `WSGI` 作为 `Python Web 应用程序` 的调度入口，它是第一步要实现的。

#### 2.3.3 URL 路由
路由的概念其实可以直接理解为从个集合` {A,B,C,D}` 中找到想要的某个元素，在 `Web 框架` 中，路由的作用其实就是从 `URL` 与处理函数的映射表之中，找到与从服务器获取到请求中的 `URL` 相匹配的处理函数。作为从 `WSGI` 入口获取到请求之后的下一步。

#### 2.3.4 视图
如果单纯的为每一个 `URL` 匹配一个处理函数，那么在开发中，每一个函数都是相对独立的，彼此之间无法有继承关系，并且对于公用的逻辑，每一次都需要在所有函数里面实现一次，而且对于路由这种写死 `URL` 与函数版定的方法，如果想要经常更改处理逻辑，那么就必须每一次都在函数之内做修改，也就是耦合度太高，所以为了低耦合度，就需要实现模块化替换和可继承的 `URL` 处理逻辑，也就是视图。

#### 2.3.5 模版引擎
它的存在则是为了实现业务逻辑层和用户界面（表现层）相关的代码进行分离。

#### 2.3.6 会话维持
对于 `HTTP 协议` 这种无状态的通信协议，我们如果要做到识别每一个请求是由哪一个客户端发起的，然后根据这个客户端本身的信息进行处理并返回对应的内容，比如登录验证通过之后，在登出之前都不需要每一次都重新登录验证一下这种功能，就需要实现 `HTTP 会话` 了，也就是要实现对消息包头中的 `Cookie` 字段进行操作的模块。

#### 2.3.7 数据库模块
大部分的 `Web 应用程序` 都会使用到数据库，所以集成一个简单易用的数据库连接模块，提前封装好常用的操作也是非常有必要的功能。

## 三、架构设计
### 3.1 前提考虑
对于软件开发中，需求随时的变动更改一直是一个普遍现象，所以从一开始就要提前为了需求修改和功能增删做好准备，核心思路就是整个架构中每一个模块都以最低的耦合度来实现，这样在后续修改和扩展时就会最大的提高灵活度。

### 3.2 项目结构
#### 目录结构设计
在 `Python` 的模块中，每一个模块都可以理解为一个包，而要让一个文件夹变成包，只需要在目录下面创建 `__init__.py` 就行，所以整个框架的结构可以这么分：

```bash
sylfk                   # 框架名字 可以自己定义
  ├── __init__.py         # 框架主体
  ├── dbconnector         # 数据库连接模块
  │     └── __init__.py
  ├── exceptions          # 异常模块
  │     └── __init__.py
  ├── helper              # 辅助模块
  │     └── __init__.py
  ├── route               # 路由模块
  │     └── __init__.py
  ├── session             # 会话模块
  │     └── __init__.py
  ├── template_engine     # 模版引擎模块
  │     └── __init.py
  ├── view                # 视图模块
  │     └── __init__.py
  └── wsgi_adapter        # WSGI 入口模块
        └── __init__.py
```

再次强调一下，在实际开发中，每个模块不仅只是简单的从结构中独立开来，还要在实现的过程中都尽量保持独立，以最低耦合度为核心需求。

为了方便学员在创建框架结构时不要做重复劳动力，我这里贴一段 `Python` 代码用来自动生成整个结构供学员快速建立自己的框架目录

注意第 11 行，框架的名字需要补全，建议为“sylfk”，这样跟后续的代码减少冲突方便实验

```python
import os

# 在当前目录下创建
root_path = os.getcwd()

# 目录列表
directory_list = [
    'dbconnector',
    'exceptions',
    'helper',
    'route',
    'session',
    'template_engine',
    'view',
    'wsgi_adapter'
]

# 子文件
children = [{'name': '__init__.py', 'children': None, 'type': 'file'}]

# 目录结构
dir_map = [{
    # name 为框架的包名，记得修改好名字，不然脚本运行会报错，建议使用与后续实验匹配的“sylfk”来命名
    'name': 框架包名,
    'children': [{
        'name': directory,
        'type': 'dir',
        'children': children
    } for directory in directory_list] + children,
    'type': 'dir'
}]


# 创建文件夹或者文件
def create(path, kind):
    if kind == 'dir':
        os.mkdir(path)
    else:
        open(path, 'w').close()


# 递归创建目录
def gen_project(parent_path, map):
    for line in map:
        path = os.path.join(parent_path, line['name'])
        create(path, line['type'])
        if line['children']:
            gen_project(path, line['children'])


# 脚本入口
def main():
    gen_project(root_path, dir_map)


if __name__ == '__main__':
    main()
```


## 四、总结
本节我们学会了如何去设计一个 `Web 框架` ，并建立好框架的目录结构。
